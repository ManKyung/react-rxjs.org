(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{154:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return b}));var a=n(2),s=n(9),o=(n(0),n(171)),r={id:"core-concepts",title:"Core Concepts",sidebar_label:"Core Concepts"},i={id:"introduction/core-concepts",isDocsHomePage:!1,title:"Core Concepts",description:"Push vs Pull",source:"@site/docs/introduction/core-concepts.md",permalink:"/react-rxjs.org/docs/introduction/core-concepts",editUrl:"https://github.com/re-rxjs/react-rxjs.org/tree/master/docs/introduction/core-concepts.md",sidebar_label:"Core Concepts",sidebar:"someSidebar",previous:{title:"Motivation",permalink:"/react-rxjs.org/docs/introduction/motivation"},next:{title:"Getting Started",permalink:"/react-rxjs.org/docs/"}},l=[{value:"Push vs Pull",id:"push-vs-pull",children:[]},{value:"Streams as state",id:"streams-as-state",children:[]},{value:"Composing streams",id:"composing-streams",children:[]},{value:"Entry points",id:"entry-points",children:[]},{value:"Suspense",id:"suspense",children:[]}],c={rightToc:l};function b(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"push-vs-pull"},"Push vs Pull"),Object(o.b)("p",null,"Historically, React uses a ",Object(o.b)("strong",{parentName:"p"},"pull"),"-based architecture. This means that when react needs to re-render, it will call the render function of every affected component, which will return a new representation of the UI, so React can reconcile with the previous one to propagate the changes to the DOM."),Object(o.b)("p",null,"This kind of behavior is called ",Object(o.b)("em",{parentName:"p"},"pull")," because the consumer (in this case, React consumes the UI representation), is the one that ",Object(o.b)("em",{parentName:"p"},"requests")," the new value."),Object(o.b)("p",null,"On the other hand, RxJS uses a ",Object(o.b)("strong",{parentName:"p"},"push"),"-based approach, where you declaratively define streams and their relationships, and RxJS will propagate every change from one stream to the next one."),Object(o.b)("p",null,"This is called ",Object(o.b)("em",{parentName:"p"},"push")," because now the producer of the state is the responsible of ",Object(o.b)("em",{parentName:"p"},"handing")," the new value over to those that depend on it. This has a positive effect: only those entities that depend on a value that has changed will update, without needing to make comparisons with the previous value to catch what parts have changed."),Object(o.b)("p",null,"This in turn not only improves performance, but also makes the state management more declarative, and in a way that can be read top-to-bottom."),Object(o.b)("p",null,"React-RxJS bridges the gap between these two behaviors, making it possible to declare a ",Object(o.b)("em",{parentName:"p"},"push")," based application state that works flawlessly with React."),Object(o.b)("h2",{id:"streams-as-state"},"Streams as state"),Object(o.b)("p",null,"RxJS streams are used to represent events or changing values over time. They have an important property: Because of their declarative nature, they don't execute the effect until someone subscribes to it."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { Observable } from "rxjs";\n\nconst first5Numbers = new Observable((obs) => {\n  console.log("hello!");\n  for (let i = 0; i < 5; i++) obs.next(i);\n  obs.complete();\n});\n// Logs nothing\n\nfirst5Numbers.subscribe((n) => {\n  console.log(n);\n});\n// Logs "hello!" followed by 0 1 2 3 4\n')),Object(o.b)("p",null,"Not only that, but they are unicast: A new subscription is created for every new observer."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { interval } from "rxjs";\nimport { take } from "rxjs/operators";\n\nconst first5SpacedNumbers = interval(1000).pipe(take(5));\n\nfirst5SpacedNumbers.subscribe((v) => console.log("A", v));\n// Will start logging A1... A2...\n\nsetTimeout(() => {\n  first5SpacedNumbers.subscribe((v) => console.log("B", v));\n}, 2000);\n// Will continue with B1... A3... B2... A4\n')),Object(o.b)("p",null,"This in a way makes might make sense because you might want to have a different state for each subscription, however, this doesn't play nicely with React. In React, you have different components, and they all need to receive the same value. Moreover, if that value dispatches a call to a service, you'd only want to make one single call to be shared among all of the components."),Object(o.b)("p",null,"RxJS has an operator that helps with this, ",Object(o.b)("inlineCode",{parentName:"p"},"share"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { interval } from "rxjs";\nimport { take, share } from "rxjs/operators";\n\nconst first5SpacedNumbers = interval(1000).pipe(take(5), share());\n\nfirst5SpacedNumbers.subscribe((v) => console.log("A", v));\n// Will start logging A1... A2...\n\nsetTimeout(() => {\n  first5SpacedNumbers.subscribe((v) => console.log("B", v));\n}, 2000);\n// Will continue with A3 B3... A4 B4...\n')),Object(o.b)("p",null,"The technical term for this is that ",Object(o.b)("inlineCode",{parentName:"p"},"share")," ",Object(o.b)("em",{parentName:"p"},"multicasts")," the stream, so that it only makes one subscription to the source, and will propagate every change to all the subscriptions of the shared stream."),Object(o.b)("p",null,"However, this now has a different issue for React's use case: If you look closely in the last snippet, even though ",Object(o.b)("inlineCode",{parentName:"p"},'"B"')," subscribed when the last value of the stream was ",Object(o.b)("inlineCode",{parentName:"p"},"2"),", it didn't receive that value. And it makes sense because the change to ",Object(o.b)("inlineCode",{parentName:"p"},"2")," was emitted in the past, so it didn't receive that change because it subscribed later."),Object(o.b)("p",null,"As React is ",Object(o.b)("em",{parentName:"p"},"pull")," based, it needs access to the latest value emitted from the stream when it needs to re-render. With the current model, it would have to wait until a new change is emitted in the stream before it can receive the new state, which wouldn't really work. Here's when React-RxJS comes into play."),Object(o.b)("p",null,"RxJS has another operator ",Object(o.b)("inlineCode",{parentName:"p"},"shareReplay")," which would cover this issue. However, it doesn't play nicely with the way that React works, because when the source completes it will keep the last values in memory indefinitely, and replay them back when a new subscriber comes without re-subscribing to the source. This not only exposes a possible memory leak, but also makes it impossible to replay e.g. a fetch call once it has already resolved."),Object(o.b)("p",null,"So that's why React-RxJS exports ",Object(o.b)("inlineCode",{parentName:"p"},"shareLatest"),". In essence, it addresses the issue of sharing the state between many components and keeping always the latest value, but without the additional issues that ",Object(o.b)("inlineCode",{parentName:"p"},"shareReplay")," exposes for this particular use case. So now our example would become:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { interval } from "rxjs";\nimport { take } from "rxjs/operators";\nimport { shareLatest } from "@react-rxjs/core";\n\nconst first5SpacedNumbers = interval(1000).pipe(take(5), shareLatest());\n\nfirst5SpacedNumbers.subscribe((v) => console.log("A", v));\n// Will start logging A1... A2...\n\nsetTimeout(() => {\n  first5SpacedNumbers.subscribe((v) => console.log("B", v));\n}, 2000);\n// Will continue with B2... A3 B3... A4 B4...\n')),Object(o.b)("p",null,"Now this stream would be ready to be consumed by React. ",Object(o.b)("inlineCode",{parentName:"p"},"shareLatest")," in a way turns a stream into a state entity. Something that owns a current value, while also providing a way to subscribe for future changes."),Object(o.b)("p",null,"The main function of React-RxJS, ",Object(o.b)("inlineCode",{parentName:"p"},"bind"),", uses this operator on every stream. ",Object(o.b)("inlineCode",{parentName:"p"},"bind")," is the function you need to use to get a React hook that will receive that value. This function not only adds ",Object(o.b)("inlineCode",{parentName:"p"},"shareLatest")," to the stream, but also does a few more tricks to integrate with React, such as:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Leveraging Suspense, so that you can represent loading states from the streams."),Object(o.b)("li",{parentName:"ul"},"Leveraging Error Boundaries to allow graceful error recoveries."),Object(o.b)("li",{parentName:"ul"},"Performance optimizations, making sure React doesn't update when it doesn't need to."),Object(o.b)("li",{parentName:"ul"},"Manages a cache of parametric observables (when using the factory overload)."),Object(o.b)("li",{parentName:"ul"},"Delays unsubscriptions from hooks to keep the stream alive between rerenders.")),Object(o.b)("p",null,"If we use bind instead, our example will look like:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { interval } from "rxjs";\nimport { take } from "rxjs/operators";\nimport { bind } from "@react-rxjs/core";\n\nconst [useFirst5SpacedNumbers, first5SpacedNumbers] = bind(\n  interval(1000).pipe(take(5))\n);\n')),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"useFirst5SpacedNumbers")," is a hook that will return just a number, which is shared for all components that use it."),Object(o.b)("p",null,"Something important to note, though, is that the subscription will happen as soon as there's a subscriber and it will be alive until there are no more subscribers. This means that if all of the components that subscribe to this stream unmount for a while, the latest value will be forgotten, and it will restart the stream when there's a new subscription."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"bind")," already handles the case of quick unmount/remount that happen quite often in React (such as when moving one component between different subtrees), but if you want to keep the subscription and the latest value alive even if the component unmounts, you can use ",Object(o.b)("inlineCode",{parentName:"p"},"<Subscribe source$={stream} />")," or ",Object(o.b)("inlineCode",{parentName:"p"},"useSubscribe(stream)")," in the relevant bit of your component tree: Within some component that will keep mounted until you don't need the subscription anymore."),Object(o.b)("h2",{id:"composing-streams"},"Composing streams"),Object(o.b)("p",null,"You might have noticed that ",Object(o.b)("inlineCode",{parentName:"p"},"bind")," returns the hook inside a tuple. This is because ",Object(o.b)("inlineCode",{parentName:"p"},"bind")," also exposes the stream with ",Object(o.b)("inlineCode",{parentName:"p"},"shareLatest")," applied so it can be easily composed."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { interval } from "rxjs";\nimport { take } from "rxjs/operators";\nimport { bind } from "@react-rxjs/core";\n\nconst [useSeconds, second$] = bind(interval(1000));\n\nconst [useLatestNSeconds, latestNSeconds$] = bind((n: number) =>\n  second$.pipe(take(n))\n);\n')),Object(o.b)("p",null,"Composition is an important factor in RxJS streams. It's often recommended to break down streams into smaller chunks, that you can later compose into more complex interactions."),Object(o.b)("p",null,"Note that you might not need to use ",Object(o.b)("inlineCode",{parentName:"p"},"bind")," on every observable. ",Object(o.b)("inlineCode",{parentName:"p"},"bind")," only makes sense when you need to get a hook for that stream, or to create a ",Object(o.b)("em",{parentName:"p"},"parametric")," observable (basically a function that returns an observable)."),Object(o.b)("h2",{id:"entry-points"},"Entry points"),Object(o.b)("p",null,"Now, where does data for the state come from? Probably the first example that we might think in RxJS is something that fetches some data:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { ajax } from "rxjs/ajax";\nimport { bind } from "@react-rxjs/core";\n\nconst [usePost, post$] = bind((id: string) => ajax.getJSON("/posts/" + id));\n')),Object(o.b)("p",null,"And of course, this will work: Any component can use ",Object(o.b)("inlineCode",{parentName:"p"},"usePost")," to fetch the post of a specific id."),Object(o.b)("p",null,"However, there are some times where we need to use data coming directly from the user. This is where RxJS ",Object(o.b)("inlineCode",{parentName:"p"},"Subject"),"s come into play."),Object(o.b)("p",null,"With a ",Object(o.b)("inlineCode",{parentName:"p"},"Subject")," you can create an entry point for your streams. For example, in a local todos app, you can define your state as:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { Subject } from "rxjs";\nimport { scan, startWith } from "rxjs/operators";\nimport { bind } from "@react-rxjs/core";\n\nconst newTodos = new Subject();\nconst postNewTodo = (todo) => newTodos.next(todo);\n\nconst [useTodoList, todoList$] = bind(\n  newTodos.pipe(\n    scan((acc, todo) => [...acc, todo], []),\n    startWith([])\n  )\n);\n')),Object(o.b)("p",null,'And now the "TodoForm" component can directly call ',Object(o.b)("inlineCode",{parentName:"p"},"postNewTodo")," whenever the user creates a todo, and the change will be propagated down to the list."),Object(o.b)("p",null,"Keep in mind that ",Object(o.b)("inlineCode",{parentName:"p"},"bind")," doesn't do magic. If no one is subscribed to ",Object(o.b)("inlineCode",{parentName:"p"},"todoList$")," (not even from the hook) then that stream won't be listening for changes on ",Object(o.b)("inlineCode",{parentName:"p"},"newTodos")," subject, and if a subscription happens late, the subject won't replay the todos created so they would get lost."),Object(o.b)("p",null,"Remember, if you have a case like this (where you are pushing a Subject but no one is subscribed to those changes), make sure you have an active subscription to the stream by using ",Object(o.b)("inlineCode",{parentName:"p"},"<Subscribe source$={stream} />")," or ",Object(o.b)("inlineCode",{parentName:"p"},"useSubscribe(stream)"),". This way, ",Object(o.b)("inlineCode",{parentName:"p"},"todoList$")," will update when a new value is pushed to the subject, and the result will be replayed for every new subscriber that comes later on."),Object(o.b)("h2",{id:"suspense"},"Suspense"),Object(o.b)("p",null,"In an earlier example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { ajax } from "rxjs/ajax";\nimport { bind } from "@react-rxjs/core";\n\nconst [usePost, post$] = bind((id: string) => ajax.getJSON("/posts/" + id));\n')),Object(o.b)("p",null,"You might be wondering - how does this ",Object(o.b)("em",{parentName:"p"},"exactly")," work with React? If React is pull-based and it ",Object(o.b)("em",{parentName:"p"},"needs")," a value at the time it's re-rendering, this stream won't have a value until the ajax call is resolved."),Object(o.b)("p",null,"Well, React added a feature called Suspense. With Suspense, we can represent values that are not yet ready, and we can notify React when those values have been loaded."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"react-rxjs")," comes with full support with Suspense, and it treats it as a first-class citizen. This means that by default, using a hook from a stream that hasn't emitted any value will result in that hook suspending the Component."),Object(o.b)("p",null,"Note that for this to work properly, you need to have proper Suspense boundaries throughout your component tree. If you don't want to use Suspense just yet the solution is simple: Make sure that the stream always has a value. In our example, if we decide that ",Object(o.b)("inlineCode",{parentName:"p"},"null")," represents missing values, the solution is as simple as:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import { ajax } from "rxjs/ajax";\nimport { startWith } from "rxjs/operators";\nimport { bind } from "@react-rxjs/core";\n\nconst [usePost, post$] = bind((id: string) =>\n  ajax.getJSON("/posts/" + id).pipe(startWith(null))\n);\n')),Object(o.b)("p",null,"Now ",Object(o.b)("inlineCode",{parentName:"p"},"usePost")," will emit ",Object(o.b)("inlineCode",{parentName:"p"},"null")," immediately while it's fetching data (so that we can manually handle that) instead of suspending the component, and when the ajax call is resolved it will emit the result of that call."),Object(o.b)("p",null,"Back to using React's Suspense, there's another way to suspend a component with ",Object(o.b)("inlineCode",{parentName:"p"},"react-rxjs")," than in the initial call: You can suspend a stream anytime by emitting ",Object(o.b)("inlineCode",{parentName:"p"},"SUSPENSE"),". For instance, this can come in handy if you need to refresh the data because some filter have changed."),Object(o.b)("p",null,"There's something to keep in mind though: React Suspense works in series within a Component. Imagine this example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"const UserProfile = () => {\n  const details = useUserDetails();\n  const posts = useUserPosts();\n\n  return (\n    <div>\n      <UserDetails details={details} />\n      <UserPosts posts={posts} />\n    </div>\n  );\n};\n")),Object(o.b)("p",null,"In this case, because of the way that Suspense works, these fetches will happen in sequential order. This means that initially ",Object(o.b)("inlineCode",{parentName:"p"},"useUserDetails")," will subscribe to ",Object(o.b)("inlineCode",{parentName:"p"},"userDetails$"),", which will start fetching data and suspend the component. When the fetch call resolves, ",Object(o.b)("inlineCode",{parentName:"p"},"useUserDetails"),' will "resume" the component, and ',Object(o.b)("inlineCode",{parentName:"p"},"useUserPosts")," will run, subscribing and fetching the data, and suspending the component yet again."),Object(o.b)("p",null,"This is usually a code smell. If you need to use many react-rxjs hooks in a component that each one will do some asynchronous work, it's often better to move this logic in a separate stream (and hook) by using composition:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const [useUserDetailsAndPosts] = bind(combineLatest(userDetail$, userPosts$));\n")),Object(o.b)("p",null,"Now ",Object(o.b)("inlineCode",{parentName:"p"},"useUserDetailsAndPosts")," will start fetching both resources and suspend the component just once for both of them."),Object(o.b)("p",null,"However, in this particular example, it would make more sense a different solution. Note that ",Object(o.b)("inlineCode",{parentName:"p"},"UserProfile")," is not using any of ",Object(o.b)("inlineCode",{parentName:"p"},"details")," or ",Object(o.b)("inlineCode",{parentName:"p"},"posts"),", so we can move the usage of those two hooks down into the components that actually use them, ",Object(o.b)("inlineCode",{parentName:"p"},"<UserDetails />")," and ",Object(o.b)("inlineCode",{parentName:"p"},"<UserPosts />"),". This way, react will render both components, and both of them will suspend at the same time, while also subscribing to both streams simultaneously."))}b.isMDXComponent=!0}}]);